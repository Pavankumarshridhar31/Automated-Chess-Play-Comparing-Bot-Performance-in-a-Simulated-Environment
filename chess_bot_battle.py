# -*- coding: utf-8 -*-
"""chess-bot-battle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UTRQClzGvgo-F2Bbto7CIropVJfL5wtZ

# Imports and Setup
"""

import requests


requests.get('http://www.google.com', timeout=10).ok
!pip install --upgrade kaggle-environments
from kaggle_environments import make
env = make("chess", debug=True)

"""This section checks internet connectivity, updates the Kaggle environments package, and sets up the chess environment.

# Submission ScriptImporting Libraries and Defining Constants
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile submission.py
# 
# from Chessnut import Game
# import random
# import time
# 
# # Thresholds and parameters for move evaluation
# threshold_1 = -8.7
# threshold_2 = 23.5
# start_val = 1.35
# temperature = 1.7
# 
# # Value map for chess pieces
# value_map = {
#     " ": 0,
#     "p": 10, "P": 10,  # Pawns
#     "n": 30, "N": 30,  # Knights
#     "b": 35, "B": 35,  # Bishops
#     "r": 50, "R": 50,  # Rooks
#     "q": 90, "Q": 90,  # Queens
#     "k": 2000, "K": 2000  # Kings
# }
#

"""necessary libraries are imported, and constants and value maps for the chess pieces are defined. The value maps assign a numerical value to each type of piece

# Board Maps
"""

# Standard positional values for pieces
standard_board_map = {
    "a8": -1, "b8": 2, "c8": 3, "d8": 3, "e8": 3, "f8": 3, "g8": 2, "h8": -1,
    "a7": 0, "b7": 1, "c7": 1, "d7": 1, "e7": 1, "f7": 1, "g7": 1, "h7": 0,
    "a6": 0, "b6": 3, "c6": 4, "d6": 4, "e6": 4, "f6": 4, "g6": 3, "h6": 0,
    "a5": 0, "b5": 3, "c5": 5, "d5": 8, "e5": 8, "f5": 5, "g5": 3, "h5": 0,
    "a4": 0, "b4": 3, "c4": 5, "d4": 8, "e4": 8, "f4": 5, "g4": 3, "h4": 0,
    "a3": 0, "b3": 3, "c3": 4, "d3": 4, "e3": 4, "f3": 4, "g3": 3, "h3": 0,
    "a2": 0, "b2": 1, "c2": 1, "d2": 1, "e2": 1, "f2": 1, "g2": 1, "h2": 0,
    "a1": -1, "b1": 2, "c1": 3, "d1": 3, "e1": 3, "f1": 3, "g1": 2, "h1": -1
}

# Positional values for kings
king_board_map = {
    "a8": -2, "b8": -2, "c8": -3, "d8": -4, "e8": -4, "f8": -3, "g8": -2, "h8": -2,
    "a7": -2, "b7": -3, "c7": -4, "d7": -5, "e7": -5, "f7": -4, "g7": -3, "h7": -2,
    "a6": -3, "b6": -4, "c6": -5, "d6": -6, "e6": -6, "f6": -5, "g6": -4, "h6": -3,
    "a5": -4, "b5": -5, "c5": -6, "d5": -7, "e5": -7, "f5": -6, "g5": -5, "h5": -4,
    "a4": -4, "b4": -5, "c4": -6, "d4": -7, "e4": -7, "f4": -6, "g4": -5, "h4": -4,
    "a3": -3, "b3": -4, "c3": -5, "d3": -6, "e3": -6, "f3": -5, "g3": -4, "h3": -3,
    "a2": -2, "b2": -3, "c2": -4, "d2": -5, "e2": -5, "f2": -4, "g2": -3, "h2": -2,
    "a1": -2, "b1": -2, "c1": -3, "d1": -4, "e1": -4, "f1": -3, "g1": -2, "h1": -2
}

# Combined board maps
board_map = {
    10: standard_board_map,
    30: standard_board_map,
    35: standard_board_map,
    50: standard_board_map,
    90: standard_board_map,
    2000: king_board_map
}

"""These maps assign positional values to each square on the board for different pieces. This helps evaluate the strategic position of pieces on the board.

# Utility Functions
"""

def check_for_simple_threat(opponent_moves, cell, piece_value):
    # Checks if a piece could be attacked by an opponent's piece
    for move in opponent_moves:
        if cell == move[2:4]:
            return piece_value
    return 0

"""This function checks if a piece could be attacked by an opponent's piece and returns its value if it is under threat.

# Move Evaluation and Selection
"""

def find_move(game, fen, time_limit):
    moves = game.get_moves()
    best_move = None
    start = time.time()
    best_value = -100

    for move in moves:
        if time.time() - start > time_limit:
            if best_move:
                return best_move
            else:
                return random.choice(moves)

        piece_value = value_map[game.board.get_piece(game.xy2i(move[:2]))]
        capture_value = value_map[game.board.get_piece(game.xy2i(move[2:4]))]
        game.apply_move(move)

        if game.status == Game.CHECKMATE:
            return move

        # Get opponent's moves and calculate potential capture value
        opponent_moves = game.get_moves()
        netto_value = capture_value - check_for_simple_threat(opponent_moves, move[2:4], piece_value)

        if netto_value >= threshold_1:
            netto_value += board_map[piece_value][move[2:4]] + random.uniform(-temperature, temperature)
            if netto_value > best_value:
                best_value = netto_value
                best_move = move
                if netto_value >= threshold_2:  # Early exit if sufficient gain is found
                    return best_move

        # Reset game state after each move
        game.set_fen(fen)

    if best_move:
        return best_move
    return random.choice(moves)

"""This function evaluates all possible moves and selects the best move based on piece values, positional values, and threats from the opponent. It uses a time limit to ensure it doesn't take too long to decide.

# Main Bot Function
"""

def chess_bot(obs):
    game = Game(fen=obs.board)  # Initialize the game state with the current FEN
    time_limit = start_val * (obs.remainingOverageTime / 10)
    # Find the "best" move using the evaluation function
    return find_move(game, obs.board, time_limit)

"""This function initializes the game state and determines the time limit for move evaluation. It then calls the find_move function to select the best move.

# Evaluation
"""

def play_games(env, agent1, agent2, num_games=10, render_last=True):
    results = {
        agent1: {"win": 0, "loss": 0, "timeouts": 0, "reward": 0},
        agent2: {"win": 0, "loss": 0, "timeouts": 0, "reward": 0},
    }

    for i in range(1, num_games + 1):
        print(f"Game: {i}")

        # Alternate which agent is White and which is Black
        if i % 2 == 1:
            white_agent, black_agent = agent1, agent2
        else:
            white_agent, black_agent = agent2, agent1

        result = env.run([white_agent, black_agent])

        # Print status for each agent at the end of the game
        for idx, agent in enumerate(result[-1]):
            color = "White" if idx == 0 else "Black"
            print(
                f"\tAgent {color} ({[white_agent, black_agent][idx]}): {agent.status} / {agent.reward} / {agent.observation.remainingOverageTime}"
            )

        # Update results for White
        if result[-1][0].reward == 1:
            results[white_agent]["win"] += 1
            results[black_agent]["loss"] += 1
            results[white_agent]["reward"] += 1
        elif result[-1][1].status == "TIMEOUT":
            results[white_agent]["reward"] += 1
        elif result[-1][0].reward == 0.5:
            results[white_agent]["reward"] += 0.5

        # Update results for Black
        if result[-1][1].reward == 1:
            results[black_agent]["win"] += 1
            results[white_agent]["loss"] += 1
            results[black_agent]["reward"] += 1
        elif result[-1][0].status == "TIMEOUT":
            results[black_agent]["reward"] += 1
        elif result[-1][1].reward == 0.5:
            results[black_agent]["reward"] += 0.5

        # Track timeouts
        if result[-1][0].status == "TIMEOUT":
            results[white_agent]["timeouts"] += 1
        if result[-1][1].status == "TIMEOUT":
            results[black_agent]["timeouts"] += 1

    # Report the results
    for agent, stats in results.items():
        print(f"\nSummary for: {agent}")
        print(f"Games Played: {num_games}")
        print(f"Timeouts: {stats['timeouts']}")
        print(f"Wins: {stats['win']}")
        print(f"Losses: {stats['loss']}")
        print(f"Average Reward: {stats['reward'] / num_games:.2f} (Timeouts as Win/Loss)")

    if render_last:
        env.render(mode="ipython", width=600, height=600)

    return results

evaluate = True
n = 10

if evaluate:
    play_games(env, "submission.py", "submission.py", num_games=10, render_last=False)  # own validation
    play_games(env, "submission.py", "/kaggle/input/chess-bot-minimax-alpha-beta-time-constraint/main.py", num_games=n)
else:
    env.render(mode="ipython")

